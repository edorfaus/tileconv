package tileconv_test

import (
	"testing"

	"github.com/edorfaus/tileconv"
)

func TestTileRowPairPlanarSize(t *testing.T) {
	check := func(bd tileconv.BitDepth, want int) {
		t.Helper()
		tp := tileconv.TileRowPairPlanar{BitDepth: bd}
		got := tp.Size()
		if got != want {
			t.Errorf("depth %v size: want %v, got %v", bd, want, got)
		}
	}
	check(tileconv.BD1, 8*2)
	check(tileconv.BD2, 8*2)
	check(tileconv.BD3, 8*4)
	check(tileconv.BD4, 8*4)
	check(tileconv.BD5, 8*6)
	check(tileconv.BD6, 8*6)
	check(tileconv.BD7, 8*8)
	check(tileconv.BD8, 8*8)
}

func TestTileRowPairPlanarEncode(t *testing.T) {
	// This table was generated by reformatting the result of calling
	// math/rand.New(rand.NewSource(0)).Read(buf) on a 8*8-long slice.
	srcPix := [][]uint8{
		{0x01, 0x94, 0xFD, 0xC2, 0xFA, 0x2F, 0xFC, 0xC0},
		{0x41, 0xD3, 0xFF, 0x12, 0x04, 0x5B, 0x73, 0xC8},
		{0x6E, 0x4F, 0xF9, 0x5F, 0xF6, 0x62, 0xA5, 0xEE},
		{0xE8, 0x2A, 0xBD, 0xF4, 0x4A, 0x2D, 0x0B, 0x75},
		{0xFB, 0x18, 0x0D, 0xAF, 0x48, 0xA7, 0x9E, 0xE0},
		{0xB1, 0x0D, 0x39, 0x46, 0x51, 0x85, 0x0F, 0xD4},
		{0xA1, 0x78, 0x89, 0x2E, 0xE2, 0x85, 0xEC, 0xE1},
		{0x51, 0x14, 0x55, 0x78, 0x08, 0x75, 0xD6, 0x4E},
	}

	// To avoid needing to repeat the encoded data, this test keeps it
	// in this slice that it will then modify as it goes. This makes it
	// necessary to run the tests starting with the highest bit depth.
	expected := []byte{
		// Planes 0-1
		0b10100100, 0b00011100,
		0b11100110, 0b01110110,
		0b01110010, 0b11011101,
		0b00100111, 0b01001010,
		0b10110100, 0b10010110,
		0b11101110, 0b00010010,
		0b10100101, 0b00011000,
		0b10100100, 0b00000011,
		// Planes 2-3
		0b01100110, 0b00101110,
		0b00101000, 0b00100101,
		0b11011011, 0b11110001,
		0b00110101, 0b11101110,
		0b00110110, 0b11111010,
		0b01010111, 0b01100010,
		0b00010110, 0b01110010,
		0b01100111, 0b00011001,
		// Planes 4-5
		0b01101010, 0b00101110,
		0b01110110, 0b00100010,
		0b00111000, 0b10101111,
		0b00110001, 0b11110101,
		0b11000010, 0b10010101,
		0b10101001, 0b10100000,
		0b01000000, 0b11011011,
		0b11110110, 0b00010100,
		// Planes 6-7
		0b00111011, 0b01111011,
		0b11100111, 0b01100001,
		0b11111101, 0b00101011,
		0b10011001, 0b10110000,
		0b10001001, 0b10010111,
		0b00011001, 0b10000101,
		0b01001011, 0b10101111,
		0b10110111, 0b00000010,
	}

	// Fills the last plane (not pair) with zeroes. This is used to set
	// up the expected data for the next odd bit depth.
	zeroLastPlane := func() {
		for i := len(expected) - 16 + 1; i < len(expected); i += 2 {
			expected[i] = 0
		}
	}

	// Drops the last plane pair in the expected data. This is used to
	// set up the expected data for the next even bit depth.
	dropLastPair := func() {
		expected = expected[:len(expected)-8*2]
	}

	runCodecEncodeTests(
		t, "BD8", tileconv.TileRowPairPlanar{BitDepth: tileconv.BD8},
		srcPix, expected,
	)

	zeroLastPlane()
	runCodecEncodeTests(
		t, "BD7", tileconv.TileRowPairPlanar{BitDepth: tileconv.BD7},
		srcPix, expected,
	)

	dropLastPair()
	runCodecEncodeTests(
		t, "BD6", tileconv.TileRowPairPlanar{BitDepth: tileconv.BD6},
		srcPix, expected,
	)

	zeroLastPlane()
	runCodecEncodeTests(
		t, "BD5", tileconv.TileRowPairPlanar{BitDepth: tileconv.BD5},
		srcPix, expected,
	)

	dropLastPair()
	runCodecEncodeTests(
		t, "BD4", tileconv.TileRowPairPlanar{BitDepth: tileconv.BD4},
		srcPix, expected,
	)

	zeroLastPlane()
	runCodecEncodeTests(
		t, "BD3", tileconv.TileRowPairPlanar{BitDepth: tileconv.BD3},
		srcPix, expected,
	)

	dropLastPair()
	runCodecEncodeTests(
		t, "BD2", tileconv.TileRowPairPlanar{BitDepth: tileconv.BD2},
		srcPix, expected,
	)

	zeroLastPlane()
	runCodecEncodeTests(
		t, "BD1", tileconv.TileRowPairPlanar{BitDepth: tileconv.BD1},
		srcPix, expected,
	)
}

func TestTileRowPairPlanarDecode(t *testing.T) {
	// To avoid needing to repeat the encoded data, this test keeps it
	// in this slice that it will then modify as it goes. This makes it
	// necessary to run the tests starting with the highest bit depth.
	source := []byte{
		// Planes 0-1
		0b10100100, 0b00011100,
		0b11100110, 0b01110110,
		0b01110010, 0b11011101,
		0b00100111, 0b01001010,
		0b10110100, 0b10010110,
		0b11101110, 0b00010010,
		0b10100101, 0b00011000,
		0b10100100, 0b00000011,
		// Planes 2-3
		0b01100110, 0b00101110,
		0b00101000, 0b00100101,
		0b11011011, 0b11110001,
		0b00110101, 0b11101110,
		0b00110110, 0b11111010,
		0b01010111, 0b01100010,
		0b00010110, 0b01110010,
		0b01100111, 0b00011001,
		// Planes 4-5
		0b01101010, 0b00101110,
		0b01110110, 0b00100010,
		0b00111000, 0b10101111,
		0b00110001, 0b11110101,
		0b11000010, 0b10010101,
		0b10101001, 0b10100000,
		0b01000000, 0b11011011,
		0b11110110, 0b00010100,
		// Planes 6-7
		0b00111011, 0b01111011,
		0b11100111, 0b01100001,
		0b11111101, 0b00101011,
		0b10011001, 0b10110000,
		0b10001001, 0b10010111,
		0b00011001, 0b10000101,
		0b01001011, 0b10101111,
		0b10110111, 0b00000010,
	}

	// This uses the same pixel data as for the Encode test above.
	wantPix := [][]uint8{
		{0x01, 0x94, 0xFD, 0xC2, 0xFA, 0x2F, 0xFC, 0xC0},
		{0x41, 0xD3, 0xFF, 0x12, 0x04, 0x5B, 0x73, 0xC8},
		{0x6E, 0x4F, 0xF9, 0x5F, 0xF6, 0x62, 0xA5, 0xEE},
		{0xE8, 0x2A, 0xBD, 0xF4, 0x4A, 0x2D, 0x0B, 0x75},
		{0xFB, 0x18, 0x0D, 0xAF, 0x48, 0xA7, 0x9E, 0xE0},
		{0xB1, 0x0D, 0x39, 0x46, 0x51, 0x85, 0x0F, 0xD4},
		{0xA1, 0x78, 0x89, 0x2E, 0xE2, 0x85, 0xEC, 0xE1},
		{0x51, 0x14, 0x55, 0x78, 0x08, 0x75, 0xD6, 0x4E},
	}

	runOddDepth := func(n string, bd tileconv.BitDepth, px [][]uint8) {
		t.Helper()

		// Test odd bit depth with non-zero last plane (aka bad data)
		runCodecDecodeTests(
			t, n+"_nz", tileconv.TileRowPairPlanar{BitDepth: bd},
			source, px,
		)

		// Fill the last plane with zeroes to prepare for the next test
		for i := len(source) - 16 + 1; i < len(source); i += 2 {
			source[i] = 0
		}

		// Test odd bit depth with zero last plane (as expected)
		runCodecDecodeTests(
			t, n+"_ok", tileconv.TileRowPairPlanar{BitDepth: bd},
			source, px,
		)
	}

	runCodecDecodeTests(
		t, "BD8", tileconv.TileRowPairPlanar{BitDepth: tileconv.BD8},
		source, wantPix,
	)

	runOddDepth("BD7", tileconv.BD7, pixBits(7, wantPix))

	// Drop the last plane pair in the source data
	source = source[:len(source)-8*2]

	runCodecDecodeTests(
		t, "BD6", tileconv.TileRowPairPlanar{BitDepth: tileconv.BD6},
		source, pixBits(6, wantPix),
	)

	runOddDepth("BD5", tileconv.BD5, pixBits(5, wantPix))

	source = source[:len(source)-8*2]

	runCodecDecodeTests(
		t, "BD4", tileconv.TileRowPairPlanar{BitDepth: tileconv.BD4},
		source, pixBits(4, wantPix),
	)

	runOddDepth("BD3", tileconv.BD3, pixBits(3, wantPix))

	source = source[:len(source)-8*2]

	runCodecDecodeTests(
		t, "BD2", tileconv.TileRowPairPlanar{BitDepth: tileconv.BD2},
		source, pixBits(2, wantPix),
	)

	runOddDepth("BD1", tileconv.BD1, pixBits(1, wantPix))
}
